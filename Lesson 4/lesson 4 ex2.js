/* ДЗ - 2
Как известно, в js не существует способа проверить идентичность объектов.
Написав 'objA === objB' мы получим true только в том случае, если objA и objB указывают на один и тот же объект.

Задача: написать функцию deepEqual, которая принимает в качестве параметров два аргуманта - два объекта.

Если обе переменные указывают на один и тот же объект, значит оба объекта идентичны.

Если оба объекта имеют одинаковые свойства и их значения, значит оба объекта идентичны.

Посмотрите на примеры того, как должна работать фиункция deepEqual:*/
var objA = {
    prop1: 'value1',
    prop2: 'value2',
    prop3: 'value3',
    prop4: {
        subProp1: 'sub value1',
        subProp2: {
            subSubProp1: 'sub sub value1',
            subSubProp2: [1, 2, {prop2: 1, prop: 2}, 4, 5]
        }
    },
    prop5: 1000,
    prop6: new Date(2016, 2, 10)
};

var objB = {
    prop5: 1000,
    prop3: 'value3',
    prop1: 'value1',
    prop2: 'value2',
    prop6: new Date(2016, 3, 10),
    prop4: {
        subProp2: {
            subSubProp1: 'sub sub value1',
            subSubProp2: [1, 2, {prop2: 1, prop: 2}, 4, 5]
        },
        subProp1: 'sub value1'
    }
}; /*

console.log(deepEqual(objA, objB)); //объекты идентичны, вернет true

Не смотря на то, что свойства в objB перемешаны(последовательность свойста в objB отичается от последовательности свойств в objA), функция всё равно вернет true, так как количество свойств, из имена и значения совпадают у обоих объектов.
Так же обратите вснимание, что deepEqual должна работать рекурсивно.

Это значит, что если значением какого-то свойства объекта является массив или объект, то начать сверять и их у обоих объектов.

Если одним из элементов сверяемого массива, является другой массив или объект, то их тоже надо сверить рекурсивно.

При сверке объектов - последовательность свойств не важна, но при сверке массивов, вашна последовательность элементов, то есть массивы: `[1,2,3,4]` и `[2,1,3,4]` не равны, так как, хотя и имеют одинаковые значения, отличаются в последовательности этих значений.

Так же обратите внимание, что даты тоже должны сравниваться корректно, не смотря на отличия в способах создания.

Запрещено использовать сторонние библиотеки типа jQuery, underscore и прочие.
*/
function getClass(obj) { // функция, определяет тип объекта
    return {}.toString.call(obj).slice(8, -1);
}

function deepEqual(objA, objB) {
    if (Object.keys(objA).length != Object.keys(objB).length) { // сравниваем количество свойств объектов, если false - объекты не идентичны.
        return 'Объекты не идентичны! 3';
    } else { // если true, то выполняется код ниже
        var i = 0;
        for (i; i < Object.keys(objB).length; i++) {// перебираем все свойства 2-го объекта
            var key = Object.keys(objA)[i]; // упрощаем доступ к названию свойства
            if (key in objB) { // проверяем каждое свойство из objA на наличие в objB
                //console.log(objA[key]); //использовал для проверки
                if (getClass(objA[key]) == "Object") { // если свойство объекта тоже - объект, то рекурсивно исполняем функцию для этого объекта по key в обоих вышестоящих объектах
                    deepEqual(objA[key], objB[key]);
                    continue;
                }
            } else { // выполняется если свойство из первого объекта не содержится во втором
                return 'Объекты не идентичны! 2';
            }
        }
    }
    return 'Объекты идентичны!';
}

console.log(deepEqual(objA, objB));
